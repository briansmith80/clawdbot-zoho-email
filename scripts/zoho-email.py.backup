#!/usr/bin/env python3
"""
Zoho Email Tool for Clawdbot
Handles: Read, Search, Monitor, Send emails
"""

import imaplib
import smtplib
import email
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from email.header import decode_header
import json
import sys
import os
import socket
import base64
from datetime import datetime, timedelta

# Load credentials from environment variables
EMAIL = os.environ.get('ZOHO_EMAIL')
PASSWORD = os.environ.get('ZOHO_PASSWORD')
IMAP_SERVER = os.environ.get('ZOHO_IMAP', 'imap.zoho.com')
SMTP_SERVER = os.environ.get('ZOHO_SMTP', 'smtp.zoho.com')
IMAP_PORT = int(os.environ.get('ZOHO_IMAP_PORT', '993'))
SMTP_PORT = int(os.environ.get('ZOHO_SMTP_PORT', '465'))

# Timeouts
IMAP_TIMEOUT = int(os.environ.get('ZOHO_TIMEOUT', '30'))
DEFAULT_SEARCH_DAYS = int(os.environ.get('ZOHO_SEARCH_DAYS', '30'))

class ZohoEmail:
    def __init__(self, verbose=False):
        if not EMAIL or not PASSWORD:
            raise ValueError("ZOHO_EMAIL and ZOHO_PASSWORD environment variables must be set")
        
        self.email = EMAIL
        self.password = PASSWORD
        self.imap_server = IMAP_SERVER
        self.smtp_server = SMTP_SERVER
        self.imap = None
        self.verbose = verbose
    
    def log(self, message):
        """Print debug messages if verbose mode is on"""
        if self.verbose:
            print(f"[DEBUG] {message}", file=sys.stderr)
    
    def connect_imap(self):
        """Connect to IMAP server with timeout"""
        try:
            self.log(f"Connecting to {self.imap_server}:{IMAP_PORT}...")
            # Set socket timeout
            socket.setdefaulttimeout(IMAP_TIMEOUT)
            self.imap = imaplib.IMAP4_SSL(self.imap_server, IMAP_PORT)
            self.log("Logging in...")
            self.imap.login(self.email, self.password)
            self.log("Connected successfully")
            return self.imap
        except imaplib.IMAP4.error as e:
            raise ConnectionError(f"IMAP authentication failed: {e}")
        except socket.timeout:
            raise ConnectionError(f"Connection timeout after {IMAP_TIMEOUT}s")
        except Exception as e:
            raise ConnectionError(f"Failed to connect to IMAP: {e}")
    
    def disconnect_imap(self):
        """Safely disconnect from IMAP"""
        if self.imap:
            try:
                self.imap.close()
            except:
                pass
            try:
                self.imap.logout()
            except:
                pass
            self.imap = None
    
    def decode_subject(self, subject):
        """Decode email subject"""
        if not subject:
            return ""
        
        try:
            decoded = decode_header(subject)
            subject_parts = []
            for part, encoding in decoded:
                if isinstance(part, bytes):
                    subject_parts.append(part.decode(encoding or 'utf-8', errors='ignore'))
                else:
                    subject_parts.append(str(part))
            return ''.join(subject_parts)
        except Exception as e:
            self.log(f"Failed to decode subject: {e}")
            return str(subject)
    
    def get_email_body(self, msg):
        """Extract email body from message"""
        body = ""
        try:
            if msg.is_multipart():
                for part in msg.walk():
                    content_type = part.get_content_type()
                    if content_type == "text/plain":
                        try:
                            body = part.get_payload(decode=True).decode('utf-8', errors='ignore')
                            break
                        except:
                            continue
            else:
                try:
                    body = msg.get_payload(decode=True).decode('utf-8', errors='ignore')
                except:
                    body = str(msg.get_payload())
        except Exception as e:
            self.log(f"Failed to extract body: {e}")
            body = "[Error extracting body]"
        
        return body
    
    def search_emails(self, folder="INBOX", query="ALL", limit=10, search_days=None):
        """Search emails in a folder"""
        search_days = search_days or DEFAULT_SEARCH_DAYS
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            # Add date filter for performance
            if search_days > 0 and query != "ALL":
                since_date = (datetime.now() - timedelta(days=search_days)).strftime("%d-%b-%Y")
                query = f'({query} SINCE {since_date})'
                self.log(f"Search query: {query}")
            
            status, messages = self.imap.search(None, query)
            
            if status != 'OK':
                raise Exception(f"Search failed: {status}")
            
            email_ids = messages[0].split()
            self.log(f"Found {len(email_ids)} emails, returning last {limit}")
            
            results = []
            for email_id in email_ids[-limit:]:  # Get last N emails
                try:
                    status, msg_data = self.imap.fetch(email_id, '(RFC822)')
                    
                    if status != 'OK':
                        continue
                    
                    for response_part in msg_data:
                        if isinstance(response_part, tuple):
                            msg = email.message_from_bytes(response_part[1])
                            
                            subject = self.decode_subject(msg.get("Subject", ""))
                            from_addr = msg.get("From", "")
                            to_addr = msg.get("To", "")
                            date = msg.get("Date", "")
                            body = self.get_email_body(msg)
                            
                            results.append({
                                "id": email_id.decode(),
                                "subject": subject,
                                "from": from_addr,
                                "to": to_addr,
                                "date": date,
                                "body": body[:500] + "..." if len(body) > 500 else body
                            })
                except Exception as e:
                    self.log(f"Error fetching email {email_id}: {e}")
                    continue
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def get_email(self, folder="INBOX", email_id=None):
        """Get a specific email by ID"""
        if not email_id:
            raise ValueError("email_id is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            status, msg_data = self.imap.fetch(str(email_id).encode(), '(RFC822)')
            
            if status != 'OK':
                raise Exception(f"Fetch failed: {status}")
            
            for response_part in msg_data:
                if isinstance(response_part, tuple):
                    msg = email.message_from_bytes(response_part[1])
                    
                    subject = self.decode_subject(msg.get("Subject", ""))
                    from_addr = msg.get("From", "")
                    to_addr = msg.get("To", "")
                    date = msg.get("Date", "")
                    body = self.get_email_body(msg)
                    
                    return {
                        "subject": subject,
                        "from": from_addr,
                        "to": to_addr,
                        "date": date,
                        "body": body
                    }
            
            raise Exception("Email not found")
        
        finally:
            self.disconnect_imap()
    
    def send_email(self, to, subject, body, cc=None, bcc=None, html_body=None):
        """Send an email via SMTP
        
        Args:
            to: Recipient email address
            subject: Email subject
            body: Plain text body (required)
            cc: CC recipients (optional)
            bcc: BCC recipients (optional)
            html_body: HTML body (optional). When provided, sends as multipart/alternative
        
        Returns:
            dict: Status information
        """
        try:
            msg = MIMEMultipart('alternative') if html_body else MIMEMultipart()
            msg['From'] = self.email
            msg['To'] = to
            msg['Subject'] = subject
            
            if cc:
                msg['Cc'] = cc
            if bcc:
                msg['Bcc'] = bcc
            
            # Attach plain text version (always include)
            msg.attach(MIMEText(body, 'plain'))
            
            # Attach HTML version if provided
            if html_body:
                msg.attach(MIMEText(html_body, 'html'))
                self.log("Sending multipart email (plain + HTML)")
            else:
                self.log("Sending plain text email")
            
            self.log(f"Sending email to {to}...")
            socket.setdefaulttimeout(IMAP_TIMEOUT)
            
            with smtplib.SMTP_SSL(self.smtp_server, SMTP_PORT) as server:
                server.login(self.email, self.password)
                server.send_message(msg)
            
            self.log("Email sent successfully")
            return {"status": "sent", "to": to, "subject": subject, "html": bool(html_body)}
        
        except Exception as e:
            raise Exception(f"Failed to send email: {e}")
    
    def send_html_email(self, to, subject, html_body, text_body=None, cc=None, bcc=None):
        """Convenience method to send HTML email with auto-generated plain text fallback
        
        Args:
            to: Recipient email address
            subject: Email subject
            html_body: HTML body content
            text_body: Plain text body (optional, auto-generated if not provided)
            cc: CC recipients (optional)
            bcc: BCC recipients (optional)
        
        Returns:
            dict: Status information
        """
        import re
        
        # Auto-generate plain text version if not provided
        if text_body is None:
            # Strip HTML tags for a basic plain text version
            text_body = re.sub('<[^<]+?>', '', html_body)
            # Clean up extra whitespace
            text_body = re.sub(r'\n\s*\n', '\n\n', text_body)
            text_body = text_body.strip()
            self.log("Auto-generated plain text fallback from HTML")
        
        return self.send_email(to, subject, text_body, cc=cc, bcc=bcc, html_body=html_body)
    
    def get_unread_count(self, folder="INBOX"):
        """Get count of unread emails"""
        try:
            self.connect_imap()
            self.log(f"Checking unread in {folder}...")
            self.imap.select(folder, readonly=True)
            
            status, messages = self.imap.search(None, 'UNSEEN')
            
            if status != 'OK':
                raise Exception(f"Unread check failed: {status}")
            
            unread_count = len(messages[0].split())
            self.log(f"Found {unread_count} unread emails")
            
            return unread_count
        
        finally:
            self.disconnect_imap()
    
    def mark_as_read(self, email_ids, folder="INBOX"):
        """Mark multiple emails as read"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    status, _ = self.imap.store(str(email_id).encode(), '+FLAGS', '\\Seen')
                    if status == 'OK':
                        self.log(f"Marked {email_id} as read")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to mark {email_id} as read")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error marking {email_id} as read: {e}")
                    results["failed"].append(email_id)
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def mark_as_unread(self, email_ids, folder="INBOX"):
        """Mark multiple emails as unread"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    status, _ = self.imap.store(str(email_id).encode(), '-FLAGS', '\\Seen')
                    if status == 'OK':
                        self.log(f"Marked {email_id} as unread")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to mark {email_id} as unread")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error marking {email_id} as unread: {e}")
                    results["failed"].append(email_id)
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def delete_emails(self, email_ids, folder="INBOX"):
        """Move multiple emails to Trash (mark as Deleted)"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    status, _ = self.imap.store(str(email_id).encode(), '+FLAGS', '\\Deleted')
                    if status == 'OK':
                        self.log(f"Marked {email_id} for deletion")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to delete {email_id}")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error deleting {email_id}: {e}")
                    results["failed"].append(email_id)
            
            # Expunge to permanently delete
            self.imap.expunge()
            self.log("Expunged deleted emails")
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def move_emails(self, email_ids, target_folder, source_folder="INBOX"):
        """Move multiple emails to another folder"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        if not target_folder:
            raise ValueError("target_folder is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting source folder: {source_folder}")
            self.imap.select(source_folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    # Copy to target folder
                    status, _ = self.imap.copy(str(email_id).encode(), target_folder)
                    if status == 'OK':
                        # Mark original as deleted
                        self.imap.store(str(email_id).encode(), '+FLAGS', '\\Deleted')
                        self.log(f"Moved {email_id} to {target_folder}")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to move {email_id}")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error moving {email_id}: {e}")
                    results["failed"].append(email_id)
            
            # Expunge to complete the move
            self.imap.expunge()
            self.log("Completed move operation")
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def bulk_action(self, query, action, folder="INBOX", limit=100, search_days=None, dry_run=False):
        """Perform bulk action on emails matching a search query
        
        Args:
            query: IMAP search query
            action: 'mark-read', 'mark-unread', 'delete', or 'move'
            folder: Source folder to search
            limit: Maximum emails to process
            search_days: Limit search to recent N days
            dry_run: If True, only show what would be done
        
        Returns:
            Dict with matched emails and action results
        """
        search_days = search_days or DEFAULT_SEARCH_DAYS
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True if dry_run else False)
            
            # Add date filter for performance
            if search_days > 0:
                since_date = (datetime.now() - timedelta(days=search_days)).strftime("%d-%b-%Y")
                query = f'({query} SINCE {since_date})'
                self.log(f"Search query: {query}")
            
            status, messages = self.imap.search(None, query)
            
            if status != 'OK':
                raise Exception(f"Search failed: {status}")
            
            email_ids = messages[0].split()
            total_found = len(email_ids)
            email_ids = email_ids[-limit:]  # Apply limit
            
            self.log(f"Found {total_found} emails, processing {len(email_ids)}")
            
            if dry_run:
                # Just return what would be affected
                previews = []
                for email_id in email_ids[:10]:  # Show first 10 as preview
                    try:
                        status, msg_data = self.imap.fetch(email_id, '(BODY[HEADER.FIELDS (SUBJECT FROM DATE)])')
                        if status == 'OK' and msg_data[0]:
                            msg = email.message_from_bytes(msg_data[0][1])
                            previews.append({
                                "id": email_id.decode(),
                                "subject": self.decode_subject(msg.get("Subject", "")),
                                "from": msg.get("From", ""),
                                "date": msg.get("Date", "")
                            })
                    except:
                        continue
                
                return {
                    "dry_run": True,
                    "total_found": total_found,
                    "to_process": len(email_ids),
                    "action": action,
                    "preview": previews
                }
            
            # Convert email_ids bytes to strings
            email_ids_str = [eid.decode() for eid in email_ids]
            
            # Disconnect to avoid readonly issues
            self.disconnect_imap()
            
            # Perform action based on type
            if action == 'mark-read':
                return self.mark_as_read(email_ids_str, folder)
            elif action == 'mark-unread':
                return self.mark_as_unread(email_ids_str, folder)
            elif action == 'delete':
                return self.delete_emails(email_ids_str, folder)
            else:
                raise ValueError(f"Unknown action: {action}. Use 'mark-read', 'mark-unread', or 'delete'")
        
        finally:
            if self.imap:
                self.disconnect_imap()

# CLI Interface
if __name__ == "__main__":
    # Check for verbose flag
    verbose = '--verbose' in sys.argv or '-v' in sys.argv
    if verbose:
        sys.argv = [arg for arg in sys.argv if arg not in ('--verbose', '-v')]
    
    try:
        zoho = ZohoEmail(verbose=verbose)
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        print("\nPlease set your Zoho credentials:", file=sys.stderr)
        print("  export ZOHO_EMAIL='your-email@domain.com'", file=sys.stderr)
        print("  export ZOHO_PASSWORD='your-app-specific-password'", file=sys.stderr)
        sys.exit(1)
    
    if len(sys.argv) < 2:
        print("Zoho Email CLI")
        print("\nUsage:")
        print("  Search sent:     python3 zoho-email.py search-sent 'keyword'")
        print("  Search inbox:    python3 zoho-email.py search 'keyword'")
        print("  Get unread:      python3 zoho-email.py unread")
        print("  Get email:       python3 zoho-email.py get <folder> <id>")
        print("  Send:            python3 zoho-email.py send <to> <subject> <body>")
        print("  Send HTML:       python3 zoho-email.py send-html <to> <subject> <html_file_or_text>")
        print("  Preview HTML:    python3 zoho-email.py preview-html <html_file_or_text>")
        print("\nOptions:")
        print("  --verbose, -v    Enable debug output")
        print("\nEnvironment:")
        print("  ZOHO_EMAIL       Your Zoho email address")
        print("  ZOHO_PASSWORD    App-specific password")
        print("  ZOHO_TIMEOUT     Connection timeout (default: 30s)")
        print("  ZOHO_SEARCH_DAYS Limit search to recent N days (default: 30)")
        sys.exit(1)
    
    command = sys.argv[1]
    
    try:
        if command == "search-sent":
            query = sys.argv[2] if len(sys.argv) > 2 else "ALL"
            # Convert to IMAP search format
            imap_query = f'SUBJECT "{query}"' if query != "ALL" else "ALL"
            results = zoho.search_emails(folder="Sent", query=imap_query, limit=5)
            print(json.dumps(results, indent=2))
        
        elif command == "search":
            query = sys.argv[2] if len(sys.argv) > 2 else "ALL"
            imap_query = f'SUBJECT "{query}"' if query != "ALL" else "ALL"
            results = zoho.search_emails(folder="INBOX", query=imap_query, limit=10)
            print(json.dumps(results, indent=2))
        
        elif command == "unread":
            count = zoho.get_unread_count()
            print(json.dumps({"unread_count": count}))
        
        elif command == "get":
            folder = sys.argv[2] if len(sys.argv) > 2 else "INBOX"
            email_id = sys.argv[3] if len(sys.argv) > 3 else None
            if not email_id:
                print("Error: email_id required", file=sys.stderr)
                sys.exit(1)
            result = zoho.get_email(folder=folder, email_id=email_id)
            print(json.dumps(result, indent=2))
        
        elif command == "send":
            to = sys.argv[2] if len(sys.argv) > 2 else None
            subject = sys.argv[3] if len(sys.argv) > 3 else None
            body = sys.argv[4] if len(sys.argv) > 4 else None
            
            if not all([to, subject, body]):
                print("Error: to, subject, and body required", file=sys.stderr)
                sys.exit(1)
            
            result = zoho.send_email(to, subject, body)
            print(json.dumps(result, indent=2))
        
        elif command == "send-html":
            to = sys.argv[2] if len(sys.argv) > 2 else None
            subject = sys.argv[3] if len(sys.argv) > 3 else None
            html_input = sys.argv[4] if len(sys.argv) > 4 else None
            
            if not all([to, subject, html_input]):
                print("Error: to, subject, and html_file_or_text required", file=sys.stderr)
                sys.exit(1)
            
            # Check if input is a file or raw HTML
            if os.path.isfile(html_input):
                with open(html_input, 'r') as f:
                    html_body = f.read()
                print(f"Loaded HTML from: {html_input}", file=sys.stderr)
            else:
                html_body = html_input
            
            result = zoho.send_html_email(to, subject, html_body)
            print(json.dumps(result, indent=2))
        
        elif command == "preview-html":
            html_input = sys.argv[2] if len(sys.argv) > 2 else None
            
            if not html_input:
                print("Error: html_file_or_text required", file=sys.stderr)
                sys.exit(1)
            
            # Check if input is a file or raw HTML
            if os.path.isfile(html_input):
                with open(html_input, 'r') as f:
                    html_body = f.read()
                print(f"Preview of: {html_input}\n", file=sys.stderr)
            else:
                html_body = html_input
                print("Preview of HTML:\n", file=sys.stderr)
            
            # Generate plain text preview
            import re
            text_preview = re.sub('<[^<]+?>', '', html_body)
            text_preview = re.sub(r'\n\s*\n', '\n\n', text_preview).strip()
            
            print("=== HTML CONTENT ===")
            print(html_body)
            print("\n=== PLAIN TEXT FALLBACK ===")
            print(text_preview)
            print("\n=== STATS ===")
            print(f"HTML length: {len(html_body)} chars")
            print(f"Plain text length: {len(text_preview)} chars")
        
        else:
            print(f"Unknown command: {command}", file=sys.stderr)
            print("Run without arguments for usage help", file=sys.stderr)
            sys.exit(1)
    
    except KeyboardInterrupt:
        print("\nInterrupted", file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
