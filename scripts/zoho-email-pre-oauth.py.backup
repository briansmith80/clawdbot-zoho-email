#!/usr/bin/env python3
"""
Zoho Email Tool for Clawdbot
Handles: Read, Search, Monitor, Send emails
"""

import imaplib
import smtplib
import email
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from email.header import decode_header
import json
import sys
import os
import socket
import base64
from datetime import datetime, timedelta

# Load credentials from environment variables
EMAIL = os.environ.get('ZOHO_EMAIL')
PASSWORD = os.environ.get('ZOHO_PASSWORD')
IMAP_SERVER = os.environ.get('ZOHO_IMAP', 'imap.zoho.com')
SMTP_SERVER = os.environ.get('ZOHO_SMTP', 'smtp.zoho.com')
IMAP_PORT = int(os.environ.get('ZOHO_IMAP_PORT', '993'))
SMTP_PORT = int(os.environ.get('ZOHO_SMTP_PORT', '465'))

# Timeouts
IMAP_TIMEOUT = int(os.environ.get('ZOHO_TIMEOUT', '30'))
DEFAULT_SEARCH_DAYS = int(os.environ.get('ZOHO_SEARCH_DAYS', '30'))

class ZohoEmail:
    def __init__(self, verbose=False):
        if not EMAIL or not PASSWORD:
            raise ValueError("ZOHO_EMAIL and ZOHO_PASSWORD environment variables must be set")
        
        self.email = EMAIL
        self.password = PASSWORD
        self.imap_server = IMAP_SERVER
        self.smtp_server = SMTP_SERVER
        self.imap = None
        self.verbose = verbose
    
    def log(self, message):
        """Print debug messages if verbose mode is on"""
        if self.verbose:
            print(f"[DEBUG] {message}", file=sys.stderr)
    
    def connect_imap(self):
        """Connect to IMAP server with timeout"""
        try:
            self.log(f"Connecting to {self.imap_server}:{IMAP_PORT}...")
            # Set socket timeout
            socket.setdefaulttimeout(IMAP_TIMEOUT)
            self.imap = imaplib.IMAP4_SSL(self.imap_server, IMAP_PORT)
            self.log("Logging in...")
            self.imap.login(self.email, self.password)
            self.log("Connected successfully")
            return self.imap
        except imaplib.IMAP4.error as e:
            raise ConnectionError(f"IMAP authentication failed: {e}")
        except socket.timeout:
            raise ConnectionError(f"Connection timeout after {IMAP_TIMEOUT}s")
        except Exception as e:
            raise ConnectionError(f"Failed to connect to IMAP: {e}")
    
    def disconnect_imap(self):
        """Safely disconnect from IMAP"""
        if self.imap:
            try:
                self.imap.close()
            except:
                pass
            try:
                self.imap.logout()
            except:
                pass
            self.imap = None
    
    def decode_subject(self, subject):
        """Decode email subject"""
        if not subject:
            return ""
        
        try:
            decoded = decode_header(subject)
            subject_parts = []
            for part, encoding in decoded:
                if isinstance(part, bytes):
                    subject_parts.append(part.decode(encoding or 'utf-8', errors='ignore'))
                else:
                    subject_parts.append(str(part))
            return ''.join(subject_parts)
        except Exception as e:
            self.log(f"Failed to decode subject: {e}")
            return str(subject)
    
    def get_email_body(self, msg):
        """Extract email body from message"""
        body = ""
        try:
            if msg.is_multipart():
                for part in msg.walk():
                    content_type = part.get_content_type()
                    if content_type == "text/plain":
                        try:
                            body = part.get_payload(decode=True).decode('utf-8', errors='ignore')
                            break
                        except:
                            continue
            else:
                try:
                    body = msg.get_payload(decode=True).decode('utf-8', errors='ignore')
                except:
                    body = str(msg.get_payload())
        except Exception as e:
            self.log(f"Failed to extract body: {e}")
            body = "[Error extracting body]"
        
        return body
    
    def search_emails(self, folder="INBOX", query="ALL", limit=10, search_days=None):
        """Search emails in a folder"""
        search_days = search_days or DEFAULT_SEARCH_DAYS
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            # Add date filter for performance
            if search_days > 0 and query != "ALL":
                since_date = (datetime.now() - timedelta(days=search_days)).strftime("%d-%b-%Y")
                query = f'({query} SINCE {since_date})'
                self.log(f"Search query: {query}")
            
            status, messages = self.imap.search(None, query)
            
            if status != 'OK':
                raise Exception(f"Search failed: {status}")
            
            email_ids = messages[0].split()
            self.log(f"Found {len(email_ids)} emails, returning last {limit}")
            
            results = []
            for email_id in email_ids[-limit:]:  # Get last N emails
                try:
                    status, msg_data = self.imap.fetch(email_id, '(RFC822)')
                    
                    if status != 'OK':
                        continue
                    
                    for response_part in msg_data:
                        if isinstance(response_part, tuple):
                            msg = email.message_from_bytes(response_part[1])
                            
                            subject = self.decode_subject(msg.get("Subject", ""))
                            from_addr = msg.get("From", "")
                            to_addr = msg.get("To", "")
                            date = msg.get("Date", "")
                            body = self.get_email_body(msg)
                            
                            results.append({
                                "id": email_id.decode(),
                                "subject": subject,
                                "from": from_addr,
                                "to": to_addr,
                                "date": date,
                                "body": body[:500] + "..." if len(body) > 500 else body
                            })
                except Exception as e:
                    self.log(f"Error fetching email {email_id}: {e}")
                    continue
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def get_email(self, folder="INBOX", email_id=None):
        """Get a specific email by ID"""
        if not email_id:
            raise ValueError("email_id is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            status, msg_data = self.imap.fetch(str(email_id).encode(), '(RFC822)')
            
            if status != 'OK':
                raise Exception(f"Fetch failed: {status}")
            
            for response_part in msg_data:
                if isinstance(response_part, tuple):
                    msg = email.message_from_bytes(response_part[1])
                    
                    subject = self.decode_subject(msg.get("Subject", ""))
                    from_addr = msg.get("From", "")
                    to_addr = msg.get("To", "")
                    date = msg.get("Date", "")
                    body = self.get_email_body(msg)
                    
                    return {
                        "subject": subject,
                        "from": from_addr,
                        "to": to_addr,
                        "date": date,
                        "body": body
                    }
            
            raise Exception("Email not found")
        
        finally:
            self.disconnect_imap()
    
    def get_attachments(self, folder="INBOX", email_id=None):
        """List attachments for a specific email"""
        if not email_id:
            raise ValueError("email_id is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            status, msg_data = self.imap.fetch(str(email_id).encode(), '(RFC822)')
            
            if status != 'OK':
                raise Exception(f"Fetch failed: {status}")
            
            attachments = []
            for response_part in msg_data:
                if isinstance(response_part, tuple):
                    msg = email.message_from_bytes(response_part[1])
                    
                    attachment_index = 0
                    for part in msg.walk():
                        # Skip multipart containers
                        if part.get_content_maintype() == 'multipart':
                            continue
                        
                        # Skip text/plain and text/html parts (body)
                        if part.get_content_type() in ['text/plain', 'text/html']:
                            continue
                        
                        # Check if this is an attachment
                        filename = part.get_filename()
                        if filename:
                            # Decode filename if needed
                            decoded = decode_header(filename)
                            filename_parts = []
                            for part_data, encoding in decoded:
                                if isinstance(part_data, bytes):
                                    filename_parts.append(part_data.decode(encoding or 'utf-8', errors='ignore'))
                                else:
                                    filename_parts.append(str(part_data))
                            filename = ''.join(filename_parts)
                            
                            attachments.append({
                                "index": attachment_index,
                                "filename": filename,
                                "content_type": part.get_content_type(),
                                "size": len(part.get_payload(decode=True) or b'')
                            })
                            attachment_index += 1
            
            return attachments
        
        finally:
            self.disconnect_imap()
    
    def download_attachment(self, folder="INBOX", email_id=None, attachment_index=0, output_path=None):
        """Download a specific attachment from an email by index"""
        if not email_id:
            raise ValueError("email_id is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            status, msg_data = self.imap.fetch(str(email_id).encode(), '(RFC822)')
            
            if status != 'OK':
                raise Exception(f"Fetch failed: {status}")
            
            for response_part in msg_data:
                if isinstance(response_part, tuple):
                    msg = email.message_from_bytes(response_part[1])
                    
                    current_index = 0
                    for part in msg.walk():
                        # Skip multipart containers
                        if part.get_content_maintype() == 'multipart':
                            continue
                        
                        # Skip text/plain and text/html parts (body)
                        if part.get_content_type() in ['text/plain', 'text/html']:
                            continue
                        
                        # Check if this is an attachment
                        filename = part.get_filename()
                        if filename:
                            if current_index == attachment_index:
                                # Decode filename
                                decoded = decode_header(filename)
                                filename_parts = []
                                for part_data, encoding in decoded:
                                    if isinstance(part_data, bytes):
                                        filename_parts.append(part_data.decode(encoding or 'utf-8', errors='ignore'))
                                    else:
                                        filename_parts.append(str(part_data))
                                filename = ''.join(filename_parts)
                                
                                # Get attachment data
                                payload = part.get_payload(decode=True)
                                
                                # Determine output path
                                if not output_path:
                                    output_path = filename
                                
                                # Write to file
                                self.log(f"Saving attachment to {output_path}")
                                with open(output_path, 'wb') as f:
                                    f.write(payload)
                                
                                return {
                                    "filename": filename,
                                    "output_path": output_path,
                                    "size": len(payload),
                                    "content_type": part.get_content_type()
                                }
                            
                            current_index += 1
            
            raise Exception(f"Attachment index {attachment_index} not found")
        
        finally:
            self.disconnect_imap()
    
    def send_email_with_attachment(self, to, subject, body, attachments=None, cc=None, bcc=None, html_body=None):
        """Send an email with one or more attachments via SMTP
        
        Args:
            to: Recipient email address
            subject: Email subject
            body: Email body text
            attachments: List of file paths to attach
            cc: CC recipients (optional)
            bcc: BCC recipients (optional)
            html_body: HTML body (optional)
        
        Returns:
            dict: Status information
        """
        try:
            msg = MIMEMultipart('mixed')
            msg['From'] = self.email
            msg['To'] = to
            msg['Subject'] = subject
            
            if cc:
                msg['Cc'] = cc
            if bcc:
                msg['Bcc'] = bcc
            
            # Create alternative part for text/html if html_body is provided
            if html_body:
                msg_alternative = MIMEMultipart('alternative')
                msg_alternative.attach(MIMEText(body, 'plain'))
                msg_alternative.attach(MIMEText(html_body, 'html'))
                msg.attach(msg_alternative)
            else:
                # Attach plain text body
                msg.attach(MIMEText(body, 'plain'))
            
            # Attach files
            if attachments:
                for file_path in attachments:
                    if not os.path.exists(file_path):
                        raise FileNotFoundError(f"Attachment not found: {file_path}")
                    
                    self.log(f"Attaching file: {file_path}")
                    
                    # Read file
                    with open(file_path, 'rb') as f:
                        file_data = f.read()
                    
                    # Create MIME part
                    part = MIMEBase('application', 'octet-stream')
                    part.set_payload(file_data)
                    encoders.encode_base64(part)
                    
                    # Add header
                    filename = os.path.basename(file_path)
                    part.add_header(
                        'Content-Disposition',
                        f'attachment; filename= {filename}'
                    )
                    
                    msg.attach(part)
            
            self.log(f"Sending email with {len(attachments or [])} attachment(s) to {to}...")
            socket.setdefaulttimeout(IMAP_TIMEOUT)
            
            with smtplib.SMTP_SSL(self.smtp_server, SMTP_PORT) as server:
                server.login(self.email, self.password)
                server.send_message(msg)
            
            self.log("Email with attachments sent successfully")
            return {
                "status": "sent",
                "to": to,
                "subject": subject,
                "attachments": len(attachments or [])
            }
        
        except Exception as e:
            raise Exception(f"Failed to send email with attachments: {e}")
    
    def send_email(self, to, subject, body, cc=None, bcc=None, html_body=None):
        """Send an email via SMTP
        
        Args:
            to: Recipient email address
            subject: Email subject
            body: Plain text body (required)
            cc: CC recipients (optional)
            bcc: BCC recipients (optional)
            html_body: HTML body (optional). When provided, sends as multipart/alternative
        
        Returns:
            dict: Status information
        """
        try:
            msg = MIMEMultipart('alternative') if html_body else MIMEMultipart()
            msg['From'] = self.email
            msg['To'] = to
            msg['Subject'] = subject
            
            if cc:
                msg['Cc'] = cc
            if bcc:
                msg['Bcc'] = bcc
            
            # Attach plain text version (always include)
            msg.attach(MIMEText(body, 'plain'))
            
            # Attach HTML version if provided
            if html_body:
                msg.attach(MIMEText(html_body, 'html'))
                self.log("Sending multipart email (plain + HTML)")
            else:
                self.log("Sending plain text email")
            
            self.log(f"Sending email to {to}...")
            socket.setdefaulttimeout(IMAP_TIMEOUT)
            
            with smtplib.SMTP_SSL(self.smtp_server, SMTP_PORT) as server:
                server.login(self.email, self.password)
                server.send_message(msg)
            
            self.log("Email sent successfully")
            return {"status": "sent", "to": to, "subject": subject, "html": bool(html_body)}
        
        except Exception as e:
            raise Exception(f"Failed to send email: {e}")
    
    def send_html_email(self, to, subject, html_body, text_body=None, cc=None, bcc=None):
        """Convenience method to send HTML email with auto-generated plain text fallback
        
        Args:
            to: Recipient email address
            subject: Email subject
            html_body: HTML body content
            text_body: Plain text body (optional, auto-generated if not provided)
            cc: CC recipients (optional)
            bcc: BCC recipients (optional)
        
        Returns:
            dict: Status information
        """
        import re
        
        # Auto-generate plain text version if not provided
        if text_body is None:
            # Strip HTML tags for a basic plain text version
            text_body = re.sub('<[^<]+?>', '', html_body)
            # Clean up extra whitespace
            text_body = re.sub(r'\n\s*\n', '\n\n', text_body)
            text_body = text_body.strip()
            self.log("Auto-generated plain text fallback from HTML")
        
        return self.send_email(to, subject, text_body, cc=cc, bcc=bcc, html_body=html_body)
    
    def get_unread_count(self, folder="INBOX"):
        """Get count of unread emails"""
        try:
            self.connect_imap()
            self.log(f"Checking unread in {folder}...")
            self.imap.select(folder, readonly=True)
            
            status, messages = self.imap.search(None, 'UNSEEN')
            
            if status != 'OK':
                raise Exception(f"Unread check failed: {status}")
            
            unread_count = len(messages[0].split())
            self.log(f"Found {unread_count} unread emails")
            
            return unread_count
        
        finally:
            self.disconnect_imap()
    
    def mark_as_read(self, email_ids, folder="INBOX"):
        """Mark multiple emails as read"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    status, _ = self.imap.store(str(email_id).encode(), '+FLAGS', '\\Seen')
                    if status == 'OK':
                        self.log(f"Marked {email_id} as read")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to mark {email_id} as read")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error marking {email_id} as read: {e}")
                    results["failed"].append(email_id)
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def mark_as_unread(self, email_ids, folder="INBOX"):
        """Mark multiple emails as unread"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    status, _ = self.imap.store(str(email_id).encode(), '-FLAGS', '\\Seen')
                    if status == 'OK':
                        self.log(f"Marked {email_id} as unread")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to mark {email_id} as unread")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error marking {email_id} as unread: {e}")
                    results["failed"].append(email_id)
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def delete_emails(self, email_ids, folder="INBOX"):
        """Move multiple emails to Trash (mark as Deleted)"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    status, _ = self.imap.store(str(email_id).encode(), '+FLAGS', '\\Deleted')
                    if status == 'OK':
                        self.log(f"Marked {email_id} for deletion")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to delete {email_id}")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error deleting {email_id}: {e}")
                    results["failed"].append(email_id)
            
            # Expunge to permanently delete
            self.imap.expunge()
            self.log("Expunged deleted emails")
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def move_emails(self, email_ids, target_folder, source_folder="INBOX"):
        """Move multiple emails to another folder"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        if not target_folder:
            raise ValueError("target_folder is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting source folder: {source_folder}")
            self.imap.select(source_folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    # Copy to target folder
                    status, _ = self.imap.copy(str(email_id).encode(), target_folder)
                    if status == 'OK':
                        # Mark original as deleted
                        self.imap.store(str(email_id).encode(), '+FLAGS', '\\Deleted')
                        self.log(f"Moved {email_id} to {target_folder}")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to move {email_id}")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error moving {email_id}: {e}")
                    results["failed"].append(email_id)
            
            # Expunge to complete the move
            self.imap.expunge()
            self.log("Completed move operation")
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def bulk_action(self, query, action, folder="INBOX", limit=100, search_days=None, dry_run=False):
        """Perform bulk action on emails matching a search query
        
        Args:
            query: IMAP search query
            action: 'mark-read', 'mark-unread', 'delete', or 'move'
            folder: Source folder to search
            limit: Maximum emails to process
            search_days: Limit search to recent N days
            dry_run: If True, only show what would be done
        
        Returns:
            Dict with matched emails and action results
        """
        search_days = search_days or DEFAULT_SEARCH_DAYS
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True if dry_run else False)
            
            # Add date filter for performance
            if search_days > 0:
                since_date = (datetime.now() - timedelta(days=search_days)).strftime("%d-%b-%Y")
                query = f'({query} SINCE {since_date})'
                self.log(f"Search query: {query}")
            
            status, messages = self.imap.search(None, query)
            
            if status != 'OK':
                raise Exception(f"Search failed: {status}")
            
            email_ids = messages[0].split()
            total_found = len(email_ids)
            email_ids = email_ids[-limit:]  # Apply limit
            
            self.log(f"Found {total_found} emails, processing {len(email_ids)}")
            
            if dry_run:
                # Just return what would be affected
                previews = []
                for email_id in email_ids[:10]:  # Show first 10 as preview
                    try:
                        status, msg_data = self.imap.fetch(email_id, '(BODY[HEADER.FIELDS (SUBJECT FROM DATE)])')
                        if status == 'OK' and msg_data[0]:
                            msg = email.message_from_bytes(msg_data[0][1])
                            previews.append({
                                "id": email_id.decode(),
                                "subject": self.decode_subject(msg.get("Subject", "")),
                                "from": msg.get("From", ""),
                                "date": msg.get("Date", "")
                            })
                    except:
                        continue
                
                return {
                    "dry_run": True,
                    "total_found": total_found,
                    "to_process": len(email_ids),
                    "action": action,
                    "preview": previews
                }
            
            # Convert email_ids bytes to strings
            email_ids_str = [eid.decode() for eid in email_ids]
            
            # Disconnect to avoid readonly issues
            self.disconnect_imap()
            
            # Perform action based on type
            if action == 'mark-read':
                return self.mark_as_read(email_ids_str, folder)
            elif action == 'mark-unread':
                return self.mark_as_unread(email_ids_str, folder)
            elif action == 'delete':
                return self.delete_emails(email_ids_str, folder)
            else:
                raise ValueError(f"Unknown action: {action}. Use 'mark-read', 'mark-unread', or 'delete'")
        
        finally:
            if self.imap:
                self.disconnect_imap()

# CLI Interface
if __name__ == "__main__":
    # Check for verbose flag
    verbose = '--verbose' in sys.argv or '-v' in sys.argv
    if verbose:
        sys.argv = [arg for arg in sys.argv if arg not in ('--verbose', '-v')]
    
    if len(sys.argv) < 2:
        print("Zoho Email CLI")
        print("\nBasic Usage:")
        print("  Search sent:     python3 zoho-email.py search-sent 'keyword'")
        print("  Search inbox:    python3 zoho-email.py search 'keyword'")
        print("  Get unread:      python3 zoho-email.py unread")
        print("  Get email:       python3 zoho-email.py get <folder> <id>")
        print("  Send:            python3 zoho-email.py send <to> <subject> <body> [--attach file1] [--attach file2]")
        print("  Send HTML:       python3 zoho-email.py send-html <to> <subject> <html_file_or_text>")
        print("  Preview HTML:    python3 zoho-email.py preview-html <html_file_or_text>")
        print("\nAttachments:")
        print("  List attachments: python3 zoho-email.py list-attachments <folder> <email_id>")
        print("  Download:        python3 zoho-email.py download-attachment <folder> <email_id> <index> [output_path]")
        print("\nBatch Operations:")
        print("  Mark as read:    python3 zoho-email.py mark-read <folder> <id1> <id2> ...")
        print("  Mark as unread:  python3 zoho-email.py mark-unread <folder> <id1> <id2> ...")
        print("  Delete emails:   python3 zoho-email.py delete <folder> <id1> <id2> ...")
        print("  Move emails:     python3 zoho-email.py move <source_folder> <target_folder> <id1> <id2> ...")
        print("  Bulk action:     python3 zoho-email.py bulk-action --folder INBOX --search 'SUBJECT \"spam\"' --action mark-read [--dry-run]")
        print("\nOptions:")
        print("  --verbose, -v    Enable debug output")
        print("  --dry-run        Preview bulk action without executing (bulk-action only)")
        print("\nEnvironment:")
        print("  ZOHO_EMAIL       Your Zoho email address")
        print("  ZOHO_PASSWORD    App-specific password")
        print("  ZOHO_TIMEOUT     Connection timeout (default: 30s)")
        print("  ZOHO_SEARCH_DAYS Limit search to recent N days (default: 30)")
        sys.exit(1)
    
    command = sys.argv[1]
    
    # Handle preview-html command without requiring credentials
    if command == "preview-html":
        html_input = sys.argv[2] if len(sys.argv) > 2 else None
        
        if not html_input:
            print("Error: html_file_or_text required", file=sys.stderr)
            sys.exit(1)
        
        # Check if input is a file or raw HTML
        if os.path.isfile(html_input):
            with open(html_input, 'r') as f:
                html_body = f.read()
            print(f"Preview of: {html_input}\n", file=sys.stderr)
        else:
            html_body = html_input
            print("Preview of HTML:\n", file=sys.stderr)
        
        # Generate plain text preview
        import re
        text_preview = re.sub('<[^<]+?>', '', html_body)
        text_preview = re.sub(r'\n\s*\n', '\n\n', text_preview).strip()
        
        print("=== HTML CONTENT ===")
        print(html_body)
        print("\n=== PLAIN TEXT FALLBACK ===")
        print(text_preview)
        print("\n=== STATS ===")
        print(f"HTML length: {len(html_body)} chars")
        print(f"Plain text length: {len(text_preview)} chars")
        sys.exit(0)
    
    # For all other commands, initialize ZohoEmail (requires credentials)
    try:
        zoho = ZohoEmail(verbose=verbose)
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        print("\nPlease set your Zoho credentials:", file=sys.stderr)
        print("  export ZOHO_EMAIL='your-email@domain.com'", file=sys.stderr)
        print("  export ZOHO_PASSWORD='your-app-specific-password'", file=sys.stderr)
        sys.exit(1)
    
    try:
        if command == "search-sent":
            query = sys.argv[2] if len(sys.argv) > 2 else "ALL"
            # Convert to IMAP search format
            imap_query = f'SUBJECT "{query}"' if query != "ALL" else "ALL"
            results = zoho.search_emails(folder="Sent", query=imap_query, limit=5)
            print(json.dumps(results, indent=2))
        
        elif command == "search":
            query = sys.argv[2] if len(sys.argv) > 2 else "ALL"
            imap_query = f'SUBJECT "{query}"' if query != "ALL" else "ALL"
            results = zoho.search_emails(folder="INBOX", query=imap_query, limit=10)
            print(json.dumps(results, indent=2))
        
        elif command == "unread":
            count = zoho.get_unread_count()
            print(json.dumps({"unread_count": count}))
        
        elif command == "get":
            folder = sys.argv[2] if len(sys.argv) > 2 else "INBOX"
            email_id = sys.argv[3] if len(sys.argv) > 3 else None
            if not email_id:
                print("Error: email_id required", file=sys.stderr)
                sys.exit(1)
            result = zoho.get_email(folder=folder, email_id=email_id)
            print(json.dumps(result, indent=2))
        
        elif command == "send":
            # Parse --attach flags
            attachments = []
            filtered_args = []
            i = 2
            while i < len(sys.argv):
                if sys.argv[i] == '--attach' and i + 1 < len(sys.argv):
                    attachments.append(sys.argv[i + 1])
                    i += 2
                else:
                    filtered_args.append(sys.argv[i])
                    i += 1
            
            to = filtered_args[0] if len(filtered_args) > 0 else None
            subject = filtered_args[1] if len(filtered_args) > 1 else None
            body = filtered_args[2] if len(filtered_args) > 2 else None
            
            if not all([to, subject, body]):
                print("Error: to, subject, and body required", file=sys.stderr)
                sys.exit(1)
            
            # Send with or without attachments
            if attachments:
                result = zoho.send_email_with_attachment(to, subject, body, attachments=attachments)
            else:
                result = zoho.send_email(to, subject, body)
            print(json.dumps(result, indent=2))
        
        elif command == "send-html":
            to = sys.argv[2] if len(sys.argv) > 2 else None
            subject = sys.argv[3] if len(sys.argv) > 3 else None
            html_input = sys.argv[4] if len(sys.argv) > 4 else None
            
            if not all([to, subject, html_input]):
                print("Error: to, subject, and html_file_or_text required", file=sys.stderr)
                sys.exit(1)
            
            # Check if input is a file or raw HTML
            if os.path.isfile(html_input):
                with open(html_input, 'r') as f:
                    html_body = f.read()
                print(f"Loaded HTML from: {html_input}", file=sys.stderr)
            else:
                html_body = html_input
            
            result = zoho.send_html_email(to, subject, html_body)
            print(json.dumps(result, indent=2))
        
            
            if not email_id:
                print("Error: email_id required", file=sys.stderr)
                sys.exit(1)
            
            attachments = zoho.get_attachments(folder=folder, email_id=email_id)
            print(json.dumps(attachments, indent=2))
        
        elif command == "download-attachment":
            folder = sys.argv[2] if len(sys.argv) > 2 else "INBOX"
            email_id = sys.argv[3] if len(sys.argv) > 3 else None
            attachment_index = int(sys.argv[4]) if len(sys.argv) > 4 else 0
            output_path = sys.argv[5] if len(sys.argv) > 5 else None
            
            if not email_id:
                print("Error: email_id required", file=sys.stderr)
                sys.exit(1)
            
            result = zoho.download_attachment(
                folder=folder,
                email_id=email_id,
                attachment_index=attachment_index,
                output_path=output_path
            )
            print(json.dumps(result, indent=2))
        
        
        elif command == "mark-read":
            if len(sys.argv) < 4:
                print("Error: folder and at least one email_id required", file=sys.stderr)
                print("Usage: python3 zoho-email.py mark-read <folder> <id1> <id2> ...", file=sys.stderr)
                sys.exit(1)
            
            folder = sys.argv[2]
            email_ids = sys.argv[3:]
            
            print(f"Marking {len(email_ids)} emails as read in folder '{folder}'...", file=sys.stderr)
            result = zoho.mark_as_read(email_ids, folder)
            print(json.dumps(result, indent=2))
            
            if result["failed"]:
                print(f"\nWarning: {len(result['failed'])} emails failed to update", file=sys.stderr)
        
        elif command == "mark-unread":
            if len(sys.argv) < 4:
                print("Error: folder and at least one email_id required", file=sys.stderr)
                print("Usage: python3 zoho-email.py mark-unread <folder> <id1> <id2> ...", file=sys.stderr)
                sys.exit(1)
            
            folder = sys.argv[2]
            email_ids = sys.argv[3:]
            
            print(f"Marking {len(email_ids)} emails as unread in folder '{folder}'...", file=sys.stderr)
            result = zoho.mark_as_unread(email_ids, folder)
            print(json.dumps(result, indent=2))
            
            if result["failed"]:
                print(f"\nWarning: {len(result['failed'])} emails failed to update", file=sys.stderr)
        
        elif command == "delete":
            if len(sys.argv) < 4:
                print("Error: folder and at least one email_id required", file=sys.stderr)
                print("Usage: python3 zoho-email.py delete <folder> <id1> <id2> ...", file=sys.stderr)
                sys.exit(1)
            
            folder = sys.argv[2]
            email_ids = sys.argv[3:]
            
            # Safety confirmation for deletions
            print(f"‚ö†Ô∏è  WARNING: About to delete {len(email_ids)} emails from '{folder}'", file=sys.stderr)
            print("Emails will be moved to Trash. Continue? (y/N): ", file=sys.stderr, end='')
            confirmation = input().strip().lower()
            
            if confirmation != 'y':
                print("Deletion cancelled.", file=sys.stderr)
                sys.exit(0)
            
            print(f"Deleting {len(email_ids)} emails...", file=sys.stderr)
            result = zoho.delete_emails(email_ids, folder)
            print(json.dumps(result, indent=2))
            
            if result["failed"]:
                print(f"\nWarning: {len(result['failed'])} emails failed to delete", file=sys.stderr)
        
        elif command == "move":
            if len(sys.argv) < 5:
                print("Error: source_folder, target_folder, and at least one email_id required", file=sys.stderr)
                print("Usage: python3 zoho-email.py move <source_folder> <target_folder> <id1> <id2> ...", file=sys.stderr)
                sys.exit(1)
            
            source_folder = sys.argv[2]
            target_folder = sys.argv[3]
            email_ids = sys.argv[4:]
            
            print(f"Moving {len(email_ids)} emails from '{source_folder}' to '{target_folder}'...", file=sys.stderr)
            result = zoho.move_emails(email_ids, target_folder, source_folder)
            print(json.dumps(result, indent=2))
            
            if result["failed"]:
                print(f"\nWarning: {len(result['failed'])} emails failed to move", file=sys.stderr)
        
        elif command == "bulk-action":
            # Parse flags
            dry_run = '--dry-run' in sys.argv
            
            # Extract parameters
            folder = None
            search_query = None
            action = None
            
            i = 2
            while i < len(sys.argv):
                if sys.argv[i] == '--folder' and i + 1 < len(sys.argv):
                    folder = sys.argv[i + 1]
                    i += 2
                elif sys.argv[i] == '--search' and i + 1 < len(sys.argv):
                    search_query = sys.argv[i + 1]
                    i += 2
                elif sys.argv[i] == '--action' and i + 1 < len(sys.argv):
                    action = sys.argv[i + 1]
                    i += 2
                elif sys.argv[i] == '--dry-run':
                    i += 1
                else:
                    i += 1
            
            if not all([folder, search_query, action]):
                print("Error: --folder, --search, and --action are required", file=sys.stderr)
                print("Usage: python3 zoho-email.py bulk-action --folder INBOX --search 'SUBJECT \"test\"' --action mark-read [--dry-run]", file=sys.stderr)
                print("Actions: mark-read, mark-unread, delete", file=sys.stderr)
                sys.exit(1)
            
            if dry_run:
                print(f"üîç DRY RUN: Searching '{folder}' for emails matching: {search_query}", file=sys.stderr)
            else:
                print(f"Executing bulk action '{action}' on '{folder}' for query: {search_query}", file=sys.stderr)
            
            result = zoho.bulk_action(search_query, action, folder=folder, dry_run=dry_run)
            print(json.dumps(result, indent=2))
            
            if dry_run and result.get("to_process", 0) > 0:
                print(f"\nüí° To execute, remove --dry-run flag", file=sys.stderr)
            elif not dry_run and result.get("failed"):
                print(f"\nWarning: {len(result['failed'])} emails failed to process", file=sys.stderr)

        else:
            print(f"Unknown command: {command}", file=sys.stderr)
            print("Run without arguments for usage help", file=sys.stderr)
            sys.exit(1)
    
    except KeyboardInterrupt:
        print("\nInterrupted", file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
