#!/usr/bin/env python3
"""
Zoho Email Tool for Clawdbot
Handles: Read, Search, Monitor, Send emails
Supports: App passwords and OAuth2 authentication
"""

import imaplib
import smtplib
import email
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from email.header import decode_header
import json
import sys
import os
import socket
import base64
import time
from datetime import datetime, timedelta

# Load credentials from environment variables
EMAIL = os.environ.get('ZOHO_EMAIL')
PASSWORD = os.environ.get('ZOHO_PASSWORD')
IMAP_SERVER = os.environ.get('ZOHO_IMAP', 'imap.zoho.com')
SMTP_SERVER = os.environ.get('ZOHO_SMTP', 'smtp.zoho.com')
IMAP_PORT = int(os.environ.get('ZOHO_IMAP_PORT', '993'))
SMTP_PORT = int(os.environ.get('ZOHO_SMTP_PORT', '465'))



# OAuth2 settings
DEFAULT_TOKEN_PATH = os.path.expanduser('~/.zoho-mail-tokens.json')
ZOHO_TOKEN_URL = 'https://accounts.zoho.com/oauth/v2/token'
# Timeouts
IMAP_TIMEOUT = int(os.environ.get('ZOHO_TIMEOUT', '30'))
DEFAULT_SEARCH_DAYS = int(os.environ.get('ZOHO_SEARCH_DAYS', '30'))


# OAuth2 Helper Functions
def load_oauth_tokens(token_path=DEFAULT_TOKEN_PATH):
    """Load OAuth2 tokens from file"""
    token_path = os.path.expanduser(token_path)
    
    if not os.path.exists(token_path):
        raise FileNotFoundError(f"Token file not found: {token_path}")
    
    try:
        with open(token_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        raise Exception(f"Failed to load tokens: {e}")

def save_oauth_tokens(token_data, token_path=DEFAULT_TOKEN_PATH):
    """Save OAuth2 tokens to file"""
    token_path = os.path.expanduser(token_path)
    
    try:
        # Create directory if needed
        os.makedirs(os.path.dirname(token_path), exist_ok=True)
        
        with open(token_path, 'w') as f:
            json.dump(token_data, f, indent=2)
        
        # Set secure permissions
        os.chmod(token_path, 0o600)
    except Exception as e:
        raise Exception(f"Failed to save tokens: {e}")

def refresh_oauth_token(client_id, client_secret, refresh_token):
    """Refresh OAuth2 access token"""
    try:
        import urllib.request
        import urllib.error
        from urllib.parse import urlencode
        
        data = urlencode({
            'grant_type': 'refresh_token',
            'client_id': client_id,
            'client_secret': client_secret,
            'refresh_token': refresh_token
        }).encode()
        
        req = urllib.request.Request(ZOHO_TOKEN_URL, data=data, method='POST')
        req.add_header('Content-Type', 'application/x-www-form-urlencoded')
        
        with urllib.request.urlopen(req, timeout=30) as response:
            result = json.loads(response.read().decode())
            return result
    
    except Exception as e:
        raise Exception(f"Token refresh failed: {e}")

def generate_oauth2_string(user, access_token):
    """Generate OAuth2 authentication string for IMAP/SMTP"""
    auth_string = f"user={user}\x01auth=Bearer {access_token}\x01\x01"
    return base64.b64encode(auth_string.encode()).decode()

def is_token_expired(token_data):
    """Check if access token is expired"""
    created_at = token_data.get('created_at', 0)
    expires_in = token_data.get('expires_in', 3600)
    expires_at = created_at + expires_in
    now = int(time.time())
    
    # Refresh if expired or expiring within 5 minutes
    return now >= (expires_at - 300)

class ZohoEmail:
    def __init__(self, verbose=False, auth_method='auto', token_file=None):
        """
        Initialize Zoho Email client
        
        Args:
            verbose: Enable debug logging
            auth_method: 'auto', 'password', or 'oauth2'
            token_file: Path to OAuth2 token file (for oauth2 auth)
        """
        self.verbose = verbose
        self.imap_server = IMAP_SERVER
        self.smtp_server = SMTP_SERVER
        self.imap = None
        
        # Determine authentication method
        self.auth_method = auth_method
        self.token_file = token_file or DEFAULT_TOKEN_PATH
        self.oauth_tokens = None
        
        if auth_method == 'auto':
            # Auto-detect: prefer OAuth2 if token file exists
            if os.path.exists(self.token_file):
                self.auth_method = 'oauth2'
                self.log(f"Auto-detected OAuth2 (token file: {self.token_file})")
            elif EMAIL and PASSWORD:
                self.auth_method = 'password'
                self.log("Auto-detected app password authentication")
            else:
                raise ValueError(
                    "No authentication method available. Set ZOHO_EMAIL/ZOHO_PASSWORD "
                    f"or configure OAuth2 (token file: {self.token_file})"
                )
        
        # Setup authentication
        if self.auth_method == 'oauth2':
            self._setup_oauth2()
        elif self.auth_method == 'password':
            self._setup_password()
        else:
            raise ValueError(f"Unknown auth method: {auth_method}")
    
    def _setup_password(self):
        """Setup app password authentication"""
        if not EMAIL or not PASSWORD:
            raise ValueError("ZOHO_EMAIL and ZOHO_PASSWORD environment variables must be set")
        
        self.email = EMAIL
        self.password = PASSWORD
        self.log("Using app password authentication")
    
    def _setup_oauth2(self):
        """Setup OAuth2 authentication"""
        try:
            self.oauth_tokens = load_oauth_tokens(self.token_file)
            
            # Validate token structure
            required_fields = ['access_token', 'refresh_token', 'client_id', 'client_secret']
            missing = [f for f in required_fields if f not in self.oauth_tokens]
            if missing:
                raise ValueError(f"Token file missing fields: {missing}")
            
            # Auto-refresh if needed
            if is_token_expired(self.oauth_tokens):
                self.log("Access token expired, refreshing...")
                self.refresh_token()
            
            # Extract email from token file or environment
            self.email = self.oauth_tokens.get('email') or EMAIL
            if not self.email:
                raise ValueError("Email address not found in token file or ZOHO_EMAIL env var")
            
            self.password = None  # Not used with OAuth2
            self.log(f"Using OAuth2 authentication for {self.email}")
        
        except FileNotFoundError:
            raise ValueError(
                f"OAuth2 token file not found: {self.token_file}\n"
                "Run 'python3 scripts/oauth-setup.py' to configure OAuth2"
            )
        except Exception as e:
            raise ValueError(f"Failed to setup OAuth2: {e}")
    
    def log(self, message):
        """Print debug messages if verbose mode is on"""
        if self.verbose:
            print(f"[DEBUG] {message}", file=sys.stderr)
    
    def refresh_token(self):
        """Refresh OAuth2 access token"""
        if self.auth_method != 'oauth2':
            raise ValueError("Token refresh only available with OAuth2 authentication")
        
        try:
            self.log("Refreshing OAuth2 token...")
            
            new_tokens = refresh_oauth_token(
                self.oauth_tokens['client_id'],
                self.oauth_tokens['client_secret'],
                self.oauth_tokens['refresh_token']
            )
            
            # Update tokens
            self.oauth_tokens['access_token'] = new_tokens['access_token']
            if 'refresh_token' in new_tokens:
                self.oauth_tokens['refresh_token'] = new_tokens['refresh_token']
            self.oauth_tokens['expires_in'] = new_tokens['expires_in']
            self.oauth_tokens['created_at'] = int(time.time())
            
            # Save updated tokens
            save_oauth_tokens(self.oauth_tokens, self.token_file)
            
            self.log("Token refreshed successfully")
            return True
        
        except Exception as e:
            raise Exception(f"Failed to refresh token: {e}")
    
    def revoke_token(self):
        """Revoke OAuth2 token (delete local token file)"""
        if self.auth_method != 'oauth2':
            raise ValueError("Token revocation only available with OAuth2 authentication")
        
        try:
            if os.path.exists(self.token_file):
                os.remove(self.token_file)
                self.log(f"Token file deleted: {self.token_file}")
                return True
            else:
                self.log("Token file does not exist")
                return False
        except Exception as e:
            raise Exception(f"Failed to revoke token: {e}")
    
    def get_token_status(self):
        """Get OAuth2 token status"""
        if self.auth_method != 'oauth2':
            return {
                'auth_method': self.auth_method,
                'status': 'not_using_oauth2'
            }
        
        created_at = self.oauth_tokens.get('created_at', 0)
        expires_in = self.oauth_tokens.get('expires_in', 3600)
        expires_at = created_at + expires_in
        now = int(time.time())
        
        return {
            'auth_method': 'oauth2',
            'status': 'expired' if is_token_expired(self.oauth_tokens) else 'valid',
            'token_file': self.token_file,
            'email': self.email,
            'created_at': created_at,
            'expires_at': expires_at,
            'expires_in_seconds': max(0, expires_at - now)
        }
    
    def connect_imap(self):
        """Connect to IMAP server with timeout"""
        try:
            self.log(f"Connecting to {self.imap_server}:{IMAP_PORT}...")
            # Set socket timeout
            socket.setdefaulttimeout(IMAP_TIMEOUT)
            self.imap = imaplib.IMAP4_SSL(self.imap_server, IMAP_PORT)
            self.log("Logging in...")
            
            if self.auth_method == 'oauth2':
                # OAuth2 authentication
                # Check if token needs refresh
                if is_token_expired(self.oauth_tokens):
                    self.log("Token expired, refreshing before login...")
                    self.refresh_token()
                
                auth_string = generate_oauth2_string(self.email, self.oauth_tokens['access_token'])
                self.imap.authenticate('XOAUTH2', lambda x: auth_string)
                self.log("OAuth2 authentication successful")
            else:
                # App password authentication
                self.imap.login(self.email, self.password)
                self.log("Password authentication successful")
            
            self.log("Connected successfully")
            return self.imap
        except imaplib.IMAP4.error as e:
            error_msg = str(e)
            if self.auth_method == 'oauth2' and 'AUTHENTICATE failed' in error_msg:
                raise ConnectionError(
                    f"IMAP OAuth2 authentication failed: {e}\n"
                    "Token may be invalid. Try: python3 scripts/zoho-email.py oauth-login"
                )
            raise ConnectionError(f"IMAP authentication failed: {e}")
        except socket.timeout:
            raise ConnectionError(f"Connection timeout after {IMAP_TIMEOUT}s")
        except Exception as e:
            raise ConnectionError(f"Failed to connect to IMAP: {e}")
    
    def disconnect_imap(self):
        """Safely disconnect from IMAP"""
        if self.imap:
            try:
                self.imap.close()
            except:
                pass
            try:
                self.imap.logout()
            except:
                pass
            self.imap = None
    
    def decode_subject(self, subject):
        """Decode email subject"""
        if not subject:
            return ""
        
        try:
            decoded = decode_header(subject)
            subject_parts = []
            for part, encoding in decoded:
                if isinstance(part, bytes):
                    subject_parts.append(part.decode(encoding or 'utf-8', errors='ignore'))
                else:
                    subject_parts.append(str(part))
            return ''.join(subject_parts)
        except Exception as e:
            self.log(f"Failed to decode subject: {e}")
            return str(subject)
    
    def get_email_body(self, msg):
        """Extract email body from message"""
        body = ""
        try:
            if msg.is_multipart():
                for part in msg.walk():
                    content_type = part.get_content_type()
                    if content_type == "text/plain":
                        try:
                            body = part.get_payload(decode=True).decode('utf-8', errors='ignore')
                            break
                        except:
                            continue
            else:
                try:
                    body = msg.get_payload(decode=True).decode('utf-8', errors='ignore')
                except:
                    body = str(msg.get_payload())
        except Exception as e:
            self.log(f"Failed to extract body: {e}")
            body = "[Error extracting body]"
        
        return body
    
    def search_emails(self, folder="INBOX", query="ALL", limit=10, search_days=None):
        """Search emails in a folder"""
        search_days = search_days or DEFAULT_SEARCH_DAYS
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            # Add date filter for performance
            if search_days > 0 and query != "ALL":
                since_date = (datetime.now() - timedelta(days=search_days)).strftime("%d-%b-%Y")
                query = f'({query} SINCE {since_date})'
                self.log(f"Search query: {query}")
            
            status, messages = self.imap.search(None, query)
            
            if status != 'OK':
                raise Exception(f"Search failed: {status}")
            
            email_ids = messages[0].split()
            self.log(f"Found {len(email_ids)} emails, returning last {limit}")
            
            results = []
            for email_id in email_ids[-limit:]:  # Get last N emails
                try:
                    status, msg_data = self.imap.fetch(email_id, '(RFC822)')
                    
                    if status != 'OK':
                        continue
                    
                    for response_part in msg_data:
                        if isinstance(response_part, tuple):
                            msg = email.message_from_bytes(response_part[1])
                            
                            subject = self.decode_subject(msg.get("Subject", ""))
                            from_addr = msg.get("From", "")
                            to_addr = msg.get("To", "")
                            date = msg.get("Date", "")
                            body = self.get_email_body(msg)
                            
                            results.append({
                                "id": email_id.decode(),
                                "subject": subject,
                                "from": from_addr,
                                "to": to_addr,
                                "date": date,
                                "body": body[:500] + "..." if len(body) > 500 else body
                            })
                except Exception as e:
                    self.log(f"Error fetching email {email_id}: {e}")
                    continue
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def get_email(self, folder="INBOX", email_id=None):
        """Get a specific email by ID"""
        if not email_id:
            raise ValueError("email_id is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            status, msg_data = self.imap.fetch(str(email_id).encode(), '(RFC822)')
            
            if status != 'OK':
                raise Exception(f"Fetch failed: {status}")
            
            for response_part in msg_data:
                if isinstance(response_part, tuple):
                    msg = email.message_from_bytes(response_part[1])
                    
                    subject = self.decode_subject(msg.get("Subject", ""))
                    from_addr = msg.get("From", "")
                    to_addr = msg.get("To", "")
                    date = msg.get("Date", "")
                    body = self.get_email_body(msg)
                    
                    return {
                        "subject": subject,
                        "from": from_addr,
                        "to": to_addr,
                        "date": date,
                        "body": body
                    }
            
            raise Exception("Email not found")
        
        finally:
            self.disconnect_imap()
    
    def get_attachments(self, folder="INBOX", email_id=None):
        """List attachments for a specific email"""
        if not email_id:
            raise ValueError("email_id is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            status, msg_data = self.imap.fetch(str(email_id).encode(), '(RFC822)')
            
            if status != 'OK':
                raise Exception(f"Fetch failed: {status}")
            
            attachments = []
            for response_part in msg_data:
                if isinstance(response_part, tuple):
                    msg = email.message_from_bytes(response_part[1])
                    
                    attachment_index = 0
                    for part in msg.walk():
                        # Skip multipart containers
                        if part.get_content_maintype() == 'multipart':
                            continue
                        
                        # Skip text/plain and text/html parts (body)
                        if part.get_content_type() in ['text/plain', 'text/html']:
                            continue
                        
                        # Check if this is an attachment
                        filename = part.get_filename()
                        if filename:
                            # Decode filename if needed
                            decoded = decode_header(filename)
                            filename_parts = []
                            for part_data, encoding in decoded:
                                if isinstance(part_data, bytes):
                                    filename_parts.append(part_data.decode(encoding or 'utf-8', errors='ignore'))
                                else:
                                    filename_parts.append(str(part_data))
                            filename = ''.join(filename_parts)
                            
                            attachments.append({
                                "index": attachment_index,
                                "filename": filename,
                                "content_type": part.get_content_type(),
                                "size": len(part.get_payload(decode=True) or b'')
                            })
                            attachment_index += 1
            
            return attachments
        
        finally:
            self.disconnect_imap()
    
    def download_attachment(self, folder="INBOX", email_id=None, attachment_index=0, output_path=None):
        """Download a specific attachment from an email by index"""
        if not email_id:
            raise ValueError("email_id is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True)
            
            status, msg_data = self.imap.fetch(str(email_id).encode(), '(RFC822)')
            
            if status != 'OK':
                raise Exception(f"Fetch failed: {status}")
            
            for response_part in msg_data:
                if isinstance(response_part, tuple):
                    msg = email.message_from_bytes(response_part[1])
                    
                    current_index = 0
                    for part in msg.walk():
                        # Skip multipart containers
                        if part.get_content_maintype() == 'multipart':
                            continue
                        
                        # Skip text/plain and text/html parts (body)
                        if part.get_content_type() in ['text/plain', 'text/html']:
                            continue
                        
                        # Check if this is an attachment
                        filename = part.get_filename()
                        if filename:
                            if current_index == attachment_index:
                                # Decode filename
                                decoded = decode_header(filename)
                                filename_parts = []
                                for part_data, encoding in decoded:
                                    if isinstance(part_data, bytes):
                                        filename_parts.append(part_data.decode(encoding or 'utf-8', errors='ignore'))
                                    else:
                                        filename_parts.append(str(part_data))
                                filename = ''.join(filename_parts)
                                
                                # Get attachment data
                                payload = part.get_payload(decode=True)
                                
                                # Determine output path
                                if not output_path:
                                    output_path = filename
                                
                                # Write to file
                                self.log(f"Saving attachment to {output_path}")
                                with open(output_path, 'wb') as f:
                                    f.write(payload)
                                
                                return {
                                    "filename": filename,
                                    "output_path": output_path,
                                    "size": len(payload),
                                    "content_type": part.get_content_type()
                                }
                            
                            current_index += 1
            
            raise Exception(f"Attachment index {attachment_index} not found")
        
        finally:
            self.disconnect_imap()
    
    
    def _smtp_login(self, server):
        """Login to SMTP server (handles OAuth2 and password)"""
        if self.auth_method == 'oauth2':
            # Check if token needs refresh
            if is_token_expired(self.oauth_tokens):
                self.log("Token expired, refreshing before SMTP login...")
                self.refresh_token()
            
            auth_string = generate_oauth2_string(self.email, self.oauth_tokens['access_token'])
            server.docmd('AUTH', 'XOAUTH2 ' + auth_string)
            self.log("SMTP OAuth2 authentication successful")
        else:
            server.login(self.email, self.password)
            self.log("SMTP password authentication successful")
    
    def send_email_with_attachment(self, to, subject, body, attachments=None, cc=None, bcc=None, html_body=None):
        """Send an email with one or more attachments via SMTP
        
        Args:
            to: Recipient email address
            subject: Email subject
            body: Email body text
            attachments: List of file paths to attach
            cc: CC recipients (optional)
            bcc: BCC recipients (optional)
            html_body: HTML body (optional)
        
        Returns:
            dict: Status information
        """
        try:
            msg = MIMEMultipart('mixed')
            msg['From'] = self.email
            msg['To'] = to
            msg['Subject'] = subject
            
            if cc:
                msg['Cc'] = cc
            if bcc:
                msg['Bcc'] = bcc
            
            # Create alternative part for text/html if html_body is provided
            if html_body:
                msg_alternative = MIMEMultipart('alternative')
                msg_alternative.attach(MIMEText(body, 'plain'))
                msg_alternative.attach(MIMEText(html_body, 'html'))
                msg.attach(msg_alternative)
            else:
                # Attach plain text body
                msg.attach(MIMEText(body, 'plain'))
            
            # Attach files
            if attachments:
                for file_path in attachments:
                    if not os.path.exists(file_path):
                        raise FileNotFoundError(f"Attachment not found: {file_path}")
                    
                    self.log(f"Attaching file: {file_path}")
                    
                    # Read file
                    with open(file_path, 'rb') as f:
                        file_data = f.read()
                    
                    # Create MIME part
                    part = MIMEBase('application', 'octet-stream')
                    part.set_payload(file_data)
                    encoders.encode_base64(part)
                    
                    # Add header
                    filename = os.path.basename(file_path)
                    part.add_header(
                        'Content-Disposition',
                        f'attachment; filename= {filename}'
                    )
                    
                    msg.attach(part)
            
            self.log(f"Sending email with {len(attachments or [])} attachment(s) to {to}...")
            socket.setdefaulttimeout(IMAP_TIMEOUT)
            
            with smtplib.SMTP_SSL(self.smtp_server, SMTP_PORT) as server:
                self._smtp_login(server)
                server.send_message(msg)
            
            self.log("Email with attachments sent successfully")
            return {
                "status": "sent",
                "to": to,
                "subject": subject,
                "attachments": len(attachments or [])
            }
        
        except Exception as e:
            raise Exception(f"Failed to send email with attachments: {e}")
    
    def send_email(self, to, subject, body, cc=None, bcc=None, html_body=None):
        """Send an email via SMTP
        
        Args:
            to: Recipient email address
            subject: Email subject
            body: Plain text body (required)
            cc: CC recipients (optional)
            bcc: BCC recipients (optional)
            html_body: HTML body (optional). When provided, sends as multipart/alternative
        
        Returns:
            dict: Status information
        """
        try:
            msg = MIMEMultipart('alternative') if html_body else MIMEMultipart()
            msg['From'] = self.email
            msg['To'] = to
            msg['Subject'] = subject
            
            if cc:
                msg['Cc'] = cc
            if bcc:
                msg['Bcc'] = bcc
            
            # Attach plain text version (always include)
            msg.attach(MIMEText(body, 'plain'))
            
            # Attach HTML version if provided
            if html_body:
                msg.attach(MIMEText(html_body, 'html'))
                self.log("Sending multipart email (plain + HTML)")
            else:
                self.log("Sending plain text email")
            
            self.log(f"Sending email to {to}...")
            socket.setdefaulttimeout(IMAP_TIMEOUT)
            
            with smtplib.SMTP_SSL(self.smtp_server, SMTP_PORT) as server:
                self._smtp_login(server)
                server.send_message(msg)
            
            self.log("Email sent successfully")
            return {"status": "sent", "to": to, "subject": subject, "html": bool(html_body), "auth_method": self.auth_method}
        
        except Exception as e:
            raise Exception(f"Failed to send email: {e}")
    
    def send_html_email(self, to, subject, html_body, text_body=None, cc=None, bcc=None):
        """Convenience method to send HTML email with auto-generated plain text fallback
        
        Args:
            to: Recipient email address
            subject: Email subject
            html_body: HTML body content
            text_body: Plain text body (optional, auto-generated if not provided)
            cc: CC recipients (optional)
            bcc: BCC recipients (optional)
        
        Returns:
            dict: Status information
        """
        import re
        
        # Auto-generate plain text version if not provided
        if text_body is None:
            # Strip HTML tags for a basic plain text version
            text_body = re.sub('<[^<]+?>', '', html_body)
            # Clean up extra whitespace
            text_body = re.sub(r'\n\s*\n', '\n\n', text_body)
            text_body = text_body.strip()
            self.log("Auto-generated plain text fallback from HTML")
        
        return self.send_email(to, subject, text_body, cc=cc, bcc=bcc, html_body=html_body)
    
    def get_unread_count(self, folder="INBOX"):
        """Get count of unread emails"""
        try:
            self.connect_imap()
            self.log(f"Checking unread in {folder}...")
            self.imap.select(folder, readonly=True)
            
            status, messages = self.imap.search(None, 'UNSEEN')
            
            if status != 'OK':
                raise Exception(f"Unread check failed: {status}")
            
            unread_count = len(messages[0].split())
            self.log(f"Found {unread_count} unread emails")
            
            return unread_count
        
        finally:
            self.disconnect_imap()
    
    def mark_as_read(self, email_ids, folder="INBOX"):
        """Mark multiple emails as read"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    status, _ = self.imap.store(str(email_id).encode(), '+FLAGS', '\\Seen')
                    if status == 'OK':
                        self.log(f"Marked {email_id} as read")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to mark {email_id} as read")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error marking {email_id} as read: {e}")
                    results["failed"].append(email_id)
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def mark_as_unread(self, email_ids, folder="INBOX"):
        """Mark multiple emails as unread"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    status, _ = self.imap.store(str(email_id).encode(), '-FLAGS', '\\Seen')
                    if status == 'OK':
                        self.log(f"Marked {email_id} as unread")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to mark {email_id} as unread")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error marking {email_id} as unread: {e}")
                    results["failed"].append(email_id)
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def delete_emails(self, email_ids, folder="INBOX"):
        """Move multiple emails to Trash (mark as Deleted)"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    status, _ = self.imap.store(str(email_id).encode(), '+FLAGS', '\\Deleted')
                    if status == 'OK':
                        self.log(f"Marked {email_id} for deletion")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to delete {email_id}")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error deleting {email_id}: {e}")
                    results["failed"].append(email_id)
            
            # Expunge to permanently delete
            self.imap.expunge()
            self.log("Expunged deleted emails")
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def move_emails(self, email_ids, target_folder, source_folder="INBOX"):
        """Move multiple emails to another folder"""
        if not email_ids:
            raise ValueError("email_ids list cannot be empty")
        if not target_folder:
            raise ValueError("target_folder is required")
        
        try:
            self.connect_imap()
            self.log(f"Selecting source folder: {source_folder}")
            self.imap.select(source_folder, readonly=False)
            
            results = {"success": [], "failed": []}
            
            for email_id in email_ids:
                try:
                    # Copy to target folder
                    status, _ = self.imap.copy(str(email_id).encode(), target_folder)
                    if status == 'OK':
                        # Mark original as deleted
                        self.imap.store(str(email_id).encode(), '+FLAGS', '\\Deleted')
                        self.log(f"Moved {email_id} to {target_folder}")
                        results["success"].append(email_id)
                    else:
                        self.log(f"Failed to move {email_id}")
                        results["failed"].append(email_id)
                except Exception as e:
                    self.log(f"Error moving {email_id}: {e}")
                    results["failed"].append(email_id)
            
            # Expunge to complete the move
            self.imap.expunge()
            self.log("Completed move operation")
            
            return results
        
        finally:
            self.disconnect_imap()
    
    def bulk_action(self, query, action, folder="INBOX", limit=100, search_days=None, dry_run=False):
        """Perform bulk action on emails matching a search query
        
        Args:
            query: IMAP search query
            action: 'mark-read', 'mark-unread', 'delete', or 'move'
            folder: Source folder to search
            limit: Maximum emails to process
            search_days: Limit search to recent N days
            dry_run: If True, only show what would be done
        
        Returns:
            Dict with matched emails and action results
        """
        search_days = search_days or DEFAULT_SEARCH_DAYS
        
        try:
            self.connect_imap()
            self.log(f"Selecting folder: {folder}")
            self.imap.select(folder, readonly=True if dry_run else False)
            
            # Add date filter for performance
            if search_days > 0:
                since_date = (datetime.now() - timedelta(days=search_days)).strftime("%d-%b-%Y")
                query = f'({query} SINCE {since_date})'
                self.log(f"Search query: {query}")
            
            status, messages = self.imap.search(None, query)
            
            if status != 'OK':
                raise Exception(f"Search failed: {status}")
            
            email_ids = messages[0].split()
            total_found = len(email_ids)
            email_ids = email_ids[-limit:]  # Apply limit
            
            self.log(f"Found {total_found} emails, processing {len(email_ids)}")
            
            if dry_run:
                # Just return what would be affected
                previews = []
                for email_id in email_ids[:10]:  # Show first 10 as preview
                    try:
                        status, msg_data = self.imap.fetch(email_id, '(BODY[HEADER.FIELDS (SUBJECT FROM DATE)])')
                        if status == 'OK' and msg_data[0]:
                            msg = email.message_from_bytes(msg_data[0][1])
                            previews.append({
                                "id": email_id.decode(),
                                "subject": self.decode_subject(msg.get("Subject", "")),
                                "from": msg.get("From", ""),
                                "date": msg.get("Date", "")
                            })
                    except:
                        continue
                
                return {
                    "dry_run": True,
                    "total_found": total_found,
                    "to_process": len(email_ids),
                    "action": action,
                    "preview": previews
                }
            
            # Convert email_ids bytes to strings
            email_ids_str = [eid.decode() for eid in email_ids]
            
            # Disconnect to avoid readonly issues
            self.disconnect_imap()
            
            # Perform action based on type
            if action == 'mark-read':
                return self.mark_as_read(email_ids_str, folder)
            elif action == 'mark-unread':
                return self.mark_as_unread(email_ids_str, folder)
            elif action == 'delete':
                return self.delete_emails(email_ids_str, folder)
            else:
                raise ValueError(f"Unknown action: {action}. Use 'mark-read', 'mark-unread', or 'delete'")
        
        finally:
            if self.imap:
                self.disconnect_imap()

# CLI Interface
if __name__ == "__main__":
    # Check for verbose flag
    verbose = '--verbose' in sys.argv or '-v' in sys.argv
    if verbose:
        sys.argv = [arg for arg in sys.argv if arg not in ('--verbose', '-v')]
    
    # Parse OAuth2 flags
    auth_method = 'auto'
    token_file = None
    
    if '--auth' in sys.argv:
        idx = sys.argv.index('--auth')
        if idx + 1 < len(sys.argv):
            auth_method = sys.argv[idx + 1]
            sys.argv = sys.argv[:idx] + sys.argv[idx+2:]
    
    if '--token-file' in sys.argv:
        idx = sys.argv.index('--token-file')
        if idx + 1 < len(sys.argv):
            token_file = sys.argv[idx + 1]
            sys.argv = sys.argv[:idx] + sys.argv[idx+2:]
    
    if len(sys.argv) < 2:
        print("Zoho Email CLI")
        print("\nBasic Usage:")
        print("  Search sent:     python3 zoho-email.py search-sent 'keyword'")
        print("  Search inbox:    python3 zoho-email.py search 'keyword'")
        print("  Get unread:      python3 zoho-email.py unread")
        print("  Get email:       python3 zoho-email.py get <folder> <id>")
        print("  Send:            python3 zoho-email.py send <to> <subject> <body> [--attach file1] [--attach file2]")
        print("  Send HTML:       python3 zoho-email.py send-html <to> <subject> <html_file_or_text>")
        print("  Preview HTML:    python3 zoho-email.py preview-html <html_file_or_text>")
        print("\nAttachments:")
        print("  List attachments: python3 zoho-email.py list-attachments <folder> <email_id>")
        print("  Download:        python3 zoho-email.py download-attachment <folder> <email_id> <index> [output_path]")
        print("\nBatch Operations:")
        print("  Mark as read:    python3 zoho-email.py mark-read <folder> <id1> <id2> ...")
        print("  Mark as unread:  python3 zoho-email.py mark-unread <folder> <id1> <id2> ...")
        print("  Delete emails:   python3 zoho-email.py delete <folder> <id1> <id2> ...")
        print("  Move emails:     python3 zoho-email.py move <source_folder> <target_folder> <id1> <id2> ...")
        print("  Bulk action:     python3 zoho-email.py bulk-action --folder INBOX --search 'SUBJECT \"spam\"' --action mark-read [--dry-run]")
        print("\nOAuth2 Commands:")
        print("  Setup OAuth2:    python3 scripts/oauth-setup.py")
        print("  Refresh tokens:  python3 zoho-email.py oauth-login [--token-file path]")
        print("  Check status:    python3 zoho-email.py oauth-status [--token-file path]")
        print("  Revoke tokens:   python3 zoho-email.py oauth-revoke [--token-file path]")
        print("\nAuthentication:")
        print("  --auth <method>      Authentication method: 'auto' (default), 'password', or 'oauth2'")
        print("  --token-file <path>  OAuth2 token file path (default: ~/.zoho-mail-tokens.json)")
        print("\nOptions:")
        print("  --verbose, -v    Enable debug output")
        print("  --dry-run        Preview bulk action without executing (bulk-action only)")
        print("\nEnvironment:")
        print("  ZOHO_EMAIL       Your Zoho email address (required for all auth methods)")
        print("  ZOHO_PASSWORD    App-specific password (for password auth)")
        print("  ZOHO_TIMEOUT     Connection timeout (default: 30s)")
        print("  ZOHO_SEARCH_DAYS Limit search to recent N days (default: 30)")
        sys.exit(1)
    
    command = sys.argv[1]
    
    # Handle preview-html command without requiring credentials
    if command == "preview-html":
        html_input = sys.argv[2] if len(sys.argv) > 2 else None
        
        if not html_input:
            print("Error: html_file_or_text required", file=sys.stderr)
            sys.exit(1)
        
        # Check if input is a file or raw HTML
        if os.path.isfile(html_input):
            with open(html_input, 'r') as f:
                html_body = f.read()
            print(f"Preview of: {html_input}\n", file=sys.stderr)
        else:
            html_body = html_input
            print("Preview of HTML:\n", file=sys.stderr)
        
        # Generate plain text preview
        import re
        text_preview = re.sub('<[^<]+?>', '', html_body)
        text_preview = re.sub(r'\n\s*\n', '\n\n', text_preview).strip()
        
        print("=== HTML CONTENT ===")
        print(html_body)
        print("\n=== PLAIN TEXT FALLBACK ===")
        print(text_preview)
        print("\n=== STATS ===")
        print(f"HTML length: {len(html_body)} chars")
        print(f"Plain text length: {len(text_preview)} chars")
        sys.exit(0)
        
    # Handle OAuth2-specific commands
    if command == "oauth-status":
        try:
            zoho = ZohoEmail(verbose=verbose, auth_method='oauth2', token_file=token_file)
            status = zoho.get_token_status()
            print(json.dumps(status, indent=2))
            
            if status['status'] == 'expired':
                print("\n⚠️  Token has expired. Run 'python3 zoho-email.py oauth-login' to refresh.", file=sys.stderr)
                sys.exit(1)
            elif status['status'] == 'valid':
                print(f"\n✓ Token is valid (expires in {status['expires_in_seconds']}s)", file=sys.stderr)
        except Exception as e:
            print(json.dumps({"status": "error", "message": str(e)}))
            sys.exit(1)
        sys.exit(0)
    
    elif command == "oauth-login":
        try:
            zoho = ZohoEmail(verbose=verbose, auth_method='oauth2', token_file=token_file)
            print(f"Refreshing OAuth2 tokens from: {zoho.token_file}", file=sys.stderr)
            zoho.refresh_token()
            status = zoho.get_token_status()
            print(json.dumps(status, indent=2))
            print(f"\n✓ Tokens refreshed successfully (expires in {status['expires_in_seconds']}s)", file=sys.stderr)
        except Exception as e:
            print(f"✗ Error: {e}", file=sys.stderr)
            print("\nIf tokens are invalid, run 'python3 scripts/oauth-setup.py' to set up OAuth2 again.", file=sys.stderr)
            sys.exit(1)
        sys.exit(0)
    
    elif command == "oauth-revoke":
        try:
            zoho = ZohoEmail(verbose=verbose, auth_method='oauth2', token_file=token_file)
            print(f"Revoking OAuth2 tokens: {zoho.token_file}", file=sys.stderr)
            zoho.revoke_token()
            print(json.dumps({"status": "revoked", "token_file": zoho.token_file}))
            print(f"\n✓ Token file deleted. Run 'python3 scripts/oauth-setup.py' to set up OAuth2 again.", file=sys.stderr)
        except Exception as e:
            print(f"✗ Error: {e}", file=sys.stderr)
            sys.exit(1)
        sys.exit(0)
    
# For all other commands, initialize ZohoEmail (requires credentials)
    try:
        zoho = ZohoEmail(verbose=verbose, auth_method=auth_method, token_file=token_file)
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        print("\nAuthentication options:", file=sys.stderr)
        print("  1. OAuth2 (recommended): Run 'python3 scripts/oauth-setup.py' to configure", file=sys.stderr)
        print("  2. App Password: Set ZOHO_EMAIL and ZOHO_PASSWORD environment variables:", file=sys.stderr)
        print("     export ZOHO_EMAIL='your-email@domain.com'", file=sys.stderr)
        print("     export ZOHO_PASSWORD='your-app-specific-password'", file=sys.stderr)
        sys.exit(1)
    
    try:
        if command == "search-sent":
            query = sys.argv[2] if len(sys.argv) > 2 else "ALL"
            # Convert to IMAP search format
            imap_query = f'SUBJECT "{query}"' if query != "ALL" else "ALL"
            results = zoho.search_emails(folder="Sent", query=imap_query, limit=5)
            print(json.dumps(results, indent=2))
        
        elif command == "search":
            query = sys.argv[2] if len(sys.argv) > 2 else "ALL"
            imap_query = f'SUBJECT "{query}"' if query != "ALL" else "ALL"
            results = zoho.search_emails(folder="INBOX", query=imap_query, limit=10)
            print(json.dumps(results, indent=2))
        
        elif command == "unread":
            count = zoho.get_unread_count()
            print(json.dumps({"unread_count": count}))
        
        elif command == "get":
            folder = sys.argv[2] if len(sys.argv) > 2 else "INBOX"
            email_id = sys.argv[3] if len(sys.argv) > 3 else None
            if not email_id:
                print("Error: email_id required", file=sys.stderr)
                sys.exit(1)
            result = zoho.get_email(folder=folder, email_id=email_id)
            print(json.dumps(result, indent=2))
        
        elif command == "send":
            # Parse --attach flags
            attachments = []
            filtered_args = []
            i = 2
            while i < len(sys.argv):
                if sys.argv[i] == '--attach' and i + 1 < len(sys.argv):
                    attachments.append(sys.argv[i + 1])
                    i += 2
                else:
                    filtered_args.append(sys.argv[i])
                    i += 1
            
            to = filtered_args[0] if len(filtered_args) > 0 else None
            subject = filtered_args[1] if len(filtered_args) > 1 else None
            body = filtered_args[2] if len(filtered_args) > 2 else None
            
            if not all([to, subject, body]):
                print("Error: to, subject, and body required", file=sys.stderr)
                sys.exit(1)
            
            # Send with or without attachments
            if attachments:
                result = zoho.send_email_with_attachment(to, subject, body, attachments=attachments)
            else:
                result = zoho.send_email(to, subject, body)
            print(json.dumps(result, indent=2))
        
        elif command == "send-html":
            to = sys.argv[2] if len(sys.argv) > 2 else None
            subject = sys.argv[3] if len(sys.argv) > 3 else None
            html_input = sys.argv[4] if len(sys.argv) > 4 else None
            
            if not all([to, subject, html_input]):
                print("Error: to, subject, and html_file_or_text required", file=sys.stderr)
                sys.exit(1)
            
            # Check if input is a file or raw HTML
            if os.path.isfile(html_input):
                with open(html_input, 'r') as f:
                    html_body = f.read()
                print(f"Loaded HTML from: {html_input}", file=sys.stderr)
            else:
                html_body = html_input
            
            result = zoho.send_html_email(to, subject, html_body)
            print(json.dumps(result, indent=2))
        
            
            if not email_id:
                print("Error: email_id required", file=sys.stderr)
                sys.exit(1)
            
            attachments = zoho.get_attachments(folder=folder, email_id=email_id)
            print(json.dumps(attachments, indent=2))
        
        elif command == "download-attachment":
            folder = sys.argv[2] if len(sys.argv) > 2 else "INBOX"
            email_id = sys.argv[3] if len(sys.argv) > 3 else None
            attachment_index = int(sys.argv[4]) if len(sys.argv) > 4 else 0
            output_path = sys.argv[5] if len(sys.argv) > 5 else None
            
            if not email_id:
                print("Error: email_id required", file=sys.stderr)
                sys.exit(1)
            
            result = zoho.download_attachment(
                folder=folder,
                email_id=email_id,
                attachment_index=attachment_index,
                output_path=output_path
            )
            print(json.dumps(result, indent=2))
        
        
        elif command == "mark-read":
            if len(sys.argv) < 4:
                print("Error: folder and at least one email_id required", file=sys.stderr)
                print("Usage: python3 zoho-email.py mark-read <folder> <id1> <id2> ...", file=sys.stderr)
                sys.exit(1)
            
            folder = sys.argv[2]
            email_ids = sys.argv[3:]
            
            print(f"Marking {len(email_ids)} emails as read in folder '{folder}'...", file=sys.stderr)
            result = zoho.mark_as_read(email_ids, folder)
            print(json.dumps(result, indent=2))
            
            if result["failed"]:
                print(f"\nWarning: {len(result['failed'])} emails failed to update", file=sys.stderr)
        
        elif command == "mark-unread":
            if len(sys.argv) < 4:
                print("Error: folder and at least one email_id required", file=sys.stderr)
                print("Usage: python3 zoho-email.py mark-unread <folder> <id1> <id2> ...", file=sys.stderr)
                sys.exit(1)
            
            folder = sys.argv[2]
            email_ids = sys.argv[3:]
            
            print(f"Marking {len(email_ids)} emails as unread in folder '{folder}'...", file=sys.stderr)
            result = zoho.mark_as_unread(email_ids, folder)
            print(json.dumps(result, indent=2))
            
            if result["failed"]:
                print(f"\nWarning: {len(result['failed'])} emails failed to update", file=sys.stderr)
        
        elif command == "delete":
            if len(sys.argv) < 4:
                print("Error: folder and at least one email_id required", file=sys.stderr)
                print("Usage: python3 zoho-email.py delete <folder> <id1> <id2> ...", file=sys.stderr)
                sys.exit(1)
            
            folder = sys.argv[2]
            email_ids = sys.argv[3:]
            
            # Safety confirmation for deletions
            print(f"⚠️  WARNING: About to delete {len(email_ids)} emails from '{folder}'", file=sys.stderr)
            print("Emails will be moved to Trash. Continue? (y/N): ", file=sys.stderr, end='')
            confirmation = input().strip().lower()
            
            if confirmation != 'y':
                print("Deletion cancelled.", file=sys.stderr)
                sys.exit(0)
            
            print(f"Deleting {len(email_ids)} emails...", file=sys.stderr)
            result = zoho.delete_emails(email_ids, folder)
            print(json.dumps(result, indent=2))
            
            if result["failed"]:
                print(f"\nWarning: {len(result['failed'])} emails failed to delete", file=sys.stderr)
        
        elif command == "move":
            if len(sys.argv) < 5:
                print("Error: source_folder, target_folder, and at least one email_id required", file=sys.stderr)
                print("Usage: python3 zoho-email.py move <source_folder> <target_folder> <id1> <id2> ...", file=sys.stderr)
                sys.exit(1)
            
            source_folder = sys.argv[2]
            target_folder = sys.argv[3]
            email_ids = sys.argv[4:]
            
            print(f"Moving {len(email_ids)} emails from '{source_folder}' to '{target_folder}'...", file=sys.stderr)
            result = zoho.move_emails(email_ids, target_folder, source_folder)
            print(json.dumps(result, indent=2))
            
            if result["failed"]:
                print(f"\nWarning: {len(result['failed'])} emails failed to move", file=sys.stderr)
        
        elif command == "bulk-action":
            # Parse flags
            dry_run = '--dry-run' in sys.argv
            
            # Extract parameters
            folder = None
            search_query = None
            action = None
            
            i = 2
            while i < len(sys.argv):
                if sys.argv[i] == '--folder' and i + 1 < len(sys.argv):
                    folder = sys.argv[i + 1]
                    i += 2
                elif sys.argv[i] == '--search' and i + 1 < len(sys.argv):
                    search_query = sys.argv[i + 1]
                    i += 2
                elif sys.argv[i] == '--action' and i + 1 < len(sys.argv):
                    action = sys.argv[i + 1]
                    i += 2
                elif sys.argv[i] == '--dry-run':
                    i += 1
                else:
                    i += 1
            
            if not all([folder, search_query, action]):
                print("Error: --folder, --search, and --action are required", file=sys.stderr)
                print("Usage: python3 zoho-email.py bulk-action --folder INBOX --search 'SUBJECT \"test\"' --action mark-read [--dry-run]", file=sys.stderr)
                print("Actions: mark-read, mark-unread, delete", file=sys.stderr)
                sys.exit(1)
            
            if dry_run:
                print(f"🔍 DRY RUN: Searching '{folder}' for emails matching: {search_query}", file=sys.stderr)
            else:
                print(f"Executing bulk action '{action}' on '{folder}' for query: {search_query}", file=sys.stderr)
            
            result = zoho.bulk_action(search_query, action, folder=folder, dry_run=dry_run)
            print(json.dumps(result, indent=2))
            
            if dry_run and result.get("to_process", 0) > 0:
                print(f"\n💡 To execute, remove --dry-run flag", file=sys.stderr)
            elif not dry_run and result.get("failed"):
                print(f"\nWarning: {len(result['failed'])} emails failed to process", file=sys.stderr)

        else:
            print(f"Unknown command: {command}", file=sys.stderr)
            print("Run without arguments for usage help", file=sys.stderr)
            sys.exit(1)
    
    except KeyboardInterrupt:
        print("\nInterrupted", file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
